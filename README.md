# Heroes Battle - Алгоритмы для пошаговой стратегии

Этот проект содержит реализацию ключевых алгоритмов для пошаговой стратегии с боевой системой. Реализованы 4 основных алгоритма:
1. **Генерация армии противника** (GeneratePreset)
2. **Симуляция пошагового боя** (SimulateBattle)
3. **Определение доступных целей для атаки** (SuitableForAttackUnitsFinder)
4. **Поиск кратчайшего пути между юнитами** (UnitTargetPathFinder)

## Структура проекта

```
src/programs/
├── GeneratePresetImpl.java          # Генерация армии компьютера
├── SimulateBattleImpl.java          # Симуляция боя между армиями
├── SuitableForAttackUnitsFinderImpl.java # Выбор доступных целей
└── UnitTargetPathFinderImpl.java    # Поиск кратчайшего пути
```

## Реализованные алгоритмы

### 1. GeneratePresetImpl

Задача: Создать максимально эффективную армию компьютера в рамках ограничений по очкам (1500) и количеству юнитов каждого типа (не более 11).

Алгоритм: Жадный алгоритм с взвешенной эффективностью
- Сортировка юнитов по эффективности: `(атака/стоимость * 0.7 + здоровье/стоимость * 0.3)`
- Последовательное заполнение армии самыми эффективными юнитами
- Учет ограничений: 11 юнитов каждого типа, 1500 очков максимум

Сложность алгоритма:
- Сортировка: O(n log n), где n = 4 (типы юнитов) → O(1)
- Заполнение армии: O(n * m), где m = макс. количество юнитов
- Итог: O(n * m) соответствует требованиям

### 2. SimulateBattleImpl

Задача: Провести пошаговый бой между армией игрока и компьютера с правильной очередностью ходов.

Алгоритм: Пошаговая симуляция с сортировкой по атаке
1. На каждом раунде сортировка всех живых юнитов по убыванию атаки
2. Поочередное выполнение ходов в порядке сортировки
3. Удаление погибших юнитов после каждого раунда
4. Использование программы юнита (`unit.getProgram().attack()`) для выбора цели

Сложность алгоритма:
- Сортировка за раунд: O(N log N), где N = количество живых юнитов
- Количество раундов в худшем случае: R = N
- Итог: O(N² log N) соответствует требованиям

### 3. SuitableForAttackUnitsFinderImpl

Задача: Определить, какие юниты противника доступны для атаки (не закрыты другими юнитами).

Алгоритм: Простой анализ позиций
- Для атаки правой армии: доступен самый правый юнит в каждом ряду
- Для атаки левой армии: доступен самый левый юнит в каждом ряду
- Игнорирование закрытых (заблокированных) юнитов

Сложность алгоритма:
- Количество рядов фиксировано: m = 3
- Обработка каждого ряда: O(1)
- Итог: O(m) = O(1) (лучше требования O(n*m))

### 4. UnitTargetPathFinderImpl

Задача: Найти кратчайший путь между атакующим и целевым юнитом на поле 27x21 с препятствиями.

Алгоритм: BFS (поиск в ширину) на сетке
- Представление поля как графа с 8-связностью (движение по прямым и диагоналям)
- Юниты как препятствия (кроме стартовой и целевой точек)
- Гарантированное нахождение кратчайшего пути
- Восстановление пути через parent-указатели

Сложность алгоритма:
- Количество вершин: V = W × H = 27 × 21 = 567
- Количество рёбер: E ≈ 8V (каждая клетка имеет до 8 соседей)
- Итог: O(V + E) = O(9V) = O(W×H) (лучше требования O((W×H)log(W×H)))